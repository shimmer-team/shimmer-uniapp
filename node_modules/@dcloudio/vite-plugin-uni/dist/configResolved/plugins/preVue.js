"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWxsCode = exports.parseWxsNodes = exports.parseBlockCode = exports.uniPreVuePlugin = void 0;
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const compiler_sfc_1 = require("@vue/compiler-sfc");
const uni_cli_shared_1 = require("@dcloudio/uni-cli-shared");
const debugPreVue = (0, debug_1.default)('uni:pre-vue');
const BLOCK_RE = /<\/block>/;
const WXS_LANG_RE = /lang=["|'](renderjs|wxs)["|']/;
const WXS_ATTRS = ['wxs', 'renderjs'];
function uniPreVuePlugin() {
    return {
        name: 'uni:pre-vue',
        async transform(code, id) {
            const { filename, query } = (0, uni_cli_shared_1.parseVueRequest)(id);
            if (query.vue) {
                return;
            }
            if (!uni_cli_shared_1.EXTNAME_VUE.includes(path_1.default.extname(filename))) {
                return;
            }
            // 清空当前页面已缓存的 filter 信息
            (0, uni_cli_shared_1.clearMiniProgramTemplateFilter)((0, uni_cli_shared_1.removeExt)((0, uni_cli_shared_1.normalizeMiniProgramFilename)(id, process.env.UNI_INPUT_DIR)));
            const hasBlock = BLOCK_RE.test(code);
            const hasWxs = WXS_LANG_RE.test(code);
            if (!hasBlock && !hasWxs) {
                return;
            }
            debugPreVue(id);
            const watchFiles = [];
            const errors = [];
            let ast = (0, uni_cli_shared_1.parseVue)(code, errors);
            if (hasBlock) {
                code = parseBlockCode(ast, code);
                // 重新解析新的 code
                ast = (0, uni_cli_shared_1.parseVue)(code, errors);
            }
            if (hasWxs) {
                const wxsNodes = parseWxsNodes(ast);
                code = parseWxsCode(wxsNodes, code);
                // add watch
                for (const wxsNode of wxsNodes) {
                    const srcProp = wxsNode.props.find((prop) => prop.type === 6 /* ATTRIBUTE */ && prop.name === 'src');
                    if (srcProp && srcProp.value) {
                        const resolveId = await this.resolve(srcProp.value.content, id);
                        if (resolveId) {
                            watchFiles.push(resolveId.id);
                        }
                    }
                }
            }
            // if (errors.length) {
            //   this.error(errors.join('\n'))
            // }
            watchFiles.forEach((file) => this.addWatchFile(file));
            return {
                code,
                map: null,
            };
        },
    };
}
exports.uniPreVuePlugin = uniPreVuePlugin;
function traverseChildren({ children }, blockNodes) {
    children.forEach((node) => traverseNode(node, blockNodes));
}
function traverseNode(node, blockNodes) {
    if ((0, uni_cli_shared_1.isElementNode)(node) && node.tag === 'block') {
        blockNodes.push(node);
    }
    if (node.type === 10 /* IF_BRANCH */ ||
        node.type === 11 /* FOR */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 0 /* ROOT */) {
        traverseChildren(node, blockNodes);
    }
}
function parseBlockCode(ast, code) {
    const blockNodes = [];
    traverseNode(ast, blockNodes);
    if (blockNodes.length) {
        return parseBlockNode(code, blockNodes);
    }
    return code;
}
exports.parseBlockCode = parseBlockCode;
const BLOCK_END_LEN = '</block>'.length;
const BLOCK_START_LEN = '<block'.length;
function parseBlockNode(code, blocks) {
    const magicString = new compiler_sfc_1.MagicString(code);
    blocks.forEach(({ loc }) => {
        const startOffset = loc.start.offset;
        const endOffset = loc.end.offset;
        magicString.overwrite(startOffset, startOffset + BLOCK_START_LEN, '<template');
        magicString.overwrite(endOffset - BLOCK_END_LEN, endOffset, '</template>');
    });
    return magicString.toString();
}
function parseWxsNodes(ast) {
    return ast.children.filter((node) => node.type === 1 /* ELEMENT */ &&
        node.tag === 'script' &&
        node.props.find((prop) => prop.name === 'lang' &&
            prop.type === 6 /* ATTRIBUTE */ &&
            prop.value &&
            WXS_ATTRS.includes(prop.value.content)));
}
exports.parseWxsNodes = parseWxsNodes;
function parseWxsCode(wxsNodes, code) {
    if (wxsNodes.length) {
        code = parseWxsNode(code, wxsNodes);
    }
    return code;
}
exports.parseWxsCode = parseWxsCode;
const SCRIPT_END_LEN = '</script>'.length;
const SCRIPT_START_LEN = '<script'.length;
function parseWxsNode(code, nodes) {
    const magicString = new compiler_sfc_1.MagicString(code);
    nodes.forEach(({ loc, props }) => {
        const langAttr = props.find((prop) => prop.name === 'lang');
        const moduleAttr = props.find((prop) => prop.name === 'module');
        const startOffset = loc.start.offset;
        const endOffset = loc.end.offset;
        const lang = langAttr.value.content;
        const langStartOffset = langAttr.loc.start.offset;
        magicString.overwrite(startOffset, startOffset + SCRIPT_START_LEN, '<' + lang); // <renderjs or <wxs
        magicString.overwrite(langStartOffset, langStartOffset + ('lang="' + lang + '"').length, ''); // remove lang="renderjs" or lang="wxs"
        magicString.overwrite(endOffset - SCRIPT_END_LEN, endOffset, '</' + lang + '>'); //</renderjs> or </wxs>
        if (moduleAttr) {
            const moduleStartOffset = moduleAttr.loc.start.offset;
            magicString.overwrite(moduleStartOffset, moduleStartOffset + 'module'.length, 'name'); // module="echarts" => name="echarts"
        }
    });
    return magicString.toString();
}
